/*
    앞에서 객체 프로퍼티의 특징을 살펴봤다.

    굳이 말로 풀어쓰지 않았지만 타입을 구분할 줄 안다면 문자형으로 해석된다는 것을 알 수 있다.
    이와 유사한 특성을 가진 객체가 하나 더 있다.

    Symbol이라는 객체인데, 이 객체는 임의 타입에 대하여 메모리를 할당해 구분 가능한 유일한 식별자가 되도록 돕는다.

    Sybmol의 생성 구문을 보면, 함수인지 클래스인지 명확히 구분하기 힘들다.
    단, 내부적으로 어떠한 동작을 할지 어느정도 예측해볼 수 있다.

    곧, 이러한 객체(또는 메소드)를 통해 생성되는 변수는 어떤 이유에서건 주어진 조건을 따라 자기 자신을 인스턴스화 하여
    해당 영역에서 독립적인 메모리를 가지도록 하기 때문이다.

    이는 곧, 현대의 클래스 생성자와 유사하다.

    반면, 필자와 달리 이를 함수와 같다고 보는 이가 있을 수 있다.
    굳이 부정하지 않겠으나, 운영체제가 유지/관리하는 가상 메모리로부터 해당 영역에서 사용할 메모리를 직접 할당하는 구조와는 엄연히 다르다.

    이러한 일련의 동작을 사용자(또는 개발자)가 대신 자동화하여 구체적인 기술을 숨기고 그저 사용할 수 있게끔 만들어 두었다면,
    언어(또는 라이브러리) 차원에서 제공하는 기능으로 볼 수 있으므로 필자는 이를 객체라 본다.

    Symbol의 메소드를 살펴보면 설명자(description), 반복자(for), 확인자(getOwnPropertySymbols, OwnKeys) 등이 있는데,
    이 부분은 필요할 때 레퍼런스를 찾아보기 바란다.

    대개, 전역적으로 유일한 대상을 가리키고자 할 때 Symbol이 특히 유용하다.
    예를 들어, 다른 개발자가 만들어 놓은 객체가 있다고 생각해보자.

    이 객체에 내가 추가하고 싶은 함수 또는 변수가 있다면 다음과 같은 방법으로 추가할 수 있다.
    
    이 동작을 간단히 하면, "새로운 프로퍼티를 추가하는 방법"으로 볼 수 있다.
*/

// 다른 개발자가 만들어 둠
const User = {
    Name = "StdSic",
    Age = 30,
}

// 내가 추가하고 싶은 함수
const ShowMyName = Symbol("Show My Name");
User[ShowMyName] = function() {console.log(this.Name);}

User[ShowMyName]();
